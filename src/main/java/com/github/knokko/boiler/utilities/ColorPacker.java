package com.github.knokko.boiler.utilities;

import static java.lang.Math.*;

/**
 * Helper class to pack RGB(A) colors into a single <b>int</b>. This is similar to what <i>java.awt.Color</i> does,
 * but the component order is different. The  advantage of this class over <i>java.awt.Color</i>,
 * is that no objects need to be allocated, you don't need to ship <i>java.desktop</i>,
 * and you don't risk triggering AWT on macOS, which could sabotage GLFW or SDL.
 */
public class ColorPacker {

	/**
	 * Takes a float in the range [0.0, 1.0], and converts it to a byte (0.0 will be mapped to 0, 1.0 will be mapped to
	 * -1).
	 */
	public static byte denormalize(float normalized) {
		int i = (int) (255 * normalized + 0.5f);
		i = min(255, max(0, i));
		return (byte) i;
	}

	/**
	 * Takes a raw byte, and converts it to a float in the range [0.0, 1.0]. This is the inverse of
	 * {@link #denormalize(float)}.
	 */
	public static float normalize(byte rawValue) {
		return unsigned(rawValue) / 255f;
	}

	/**
	 * Packs red, green, blue, and alpha into an integer. The red component will be stored in the least-significant
	 * 8 bits, the green component will be stored in the next 8 bits, etc...
	 */
	public static int rgba(byte red, byte green, byte blue, byte alpha) {
		return unsigned(red) | (unsigned(green) << 8) | (unsigned(blue) << 16) | (unsigned(alpha) << 24);
	}

	/**
	 * Packs red, green, blue, and alpha into an integer. The red component will be stored in the least-significant
	 * 8 bits, the green component will be stored in the next 8 bits, etc...<br>
	 *
	 * You can give the parameters either in the range [-128, 127] or [0, 255].
	 */
	public static int rgba(int red, int green, int blue, int alpha) {
		return rgba((byte) red, (byte) green, (byte) blue, (byte) alpha);
	}

	/**
	 * Packs red, green, blue, and alpha into an integer. The red component will be stored in the least-significant
	 * 8 bits, the green component will be stored in the next 8 bits, etc...<br>
	 *
	 * You must give the parameters in the range [0.0, 1.0]
	 */
	public static int rgba(float red, float green, float blue, float alpha) {
		return rgba(denormalize(red), denormalize(green), denormalize(blue), denormalize(alpha));
	}

	/**
	 * Packs red, green, and blue into an integer. The red component will be stored in the least-significant
	 * 8 bits, the green component will be stored in the next 8 bits, and the blue component will be stored next to
	 * green. The 8 most-significant bits will be set to 1, making the stored color opaque.
	 */
	public static int rgb(byte red, byte green, byte blue) {
		return rgba(red, green, blue, (byte) 255);
	}

	/**
	 * Packs red, green, and blue into an integer. The red component will be stored in the least-significant
	 * 8 bits, the green component will be stored in the next 8 bits, and the blue component will be stored next to
	 * green. The 8 most-significant bits will be set to 1, making the stored color opaque.<br>
	 *
	 * You can give the parameters either in the range [-128, 127] or [0, 255].
	 */
	public static int rgb(int red, int green, int blue) {
		return rgba(red, green, blue, 255);
	}

	/**
	 * Packs red, green, and blue into an integer. The red component will be stored in the least-significant
	 * 8 bits, the green component will be stored in the next 8 bits, and the blue component will be stored next to
	 * green. The 8 most-significant bits will be set to 1, making the stored color opaque.<br>
	 *
	 * You must give the parameters in the range [0.0, 1.0].
	 */
	public static int rgb(float red, float green, float blue) {
		return rgba(red, green, blue, 1f);
	}

	/**
	 * Extracts the red component from a rgba value generated by the <i>rgba</i> method
	 */
	public static byte red(int rgba) {
		return (byte) rgba;
	}

	/**
	 * Extracts the green component from a rgba value generated by the <i>rgba</i> method
	 */
	public static byte green(int rgba) {
		return (byte) (rgba >> 8);
	}

	/**
	 * Extracts the blue component from a rgba value generated by the <i>rgba</i> method
	 */
	public static byte blue(int rgba) {
		return (byte) (rgba >> 16);
	}

	/**
	 * Extracts the alpha component from a rgba value generated by the <i>rgba</i> method
	 */
	public static byte alpha(int rgba) {
		return (byte) (rgba >> 24);
	}

	/**
	 * Converts a <b>byte</b> (in the range [-128, 127]) to an <b>int</b> in the range [0, 255]
	 */
	public static int unsigned(byte value) {
		return value & 0xFF;
	}

	/**
	 * Returns a nice string showing the R, G, B, and A component of the packed color, like RGB(1, 2, 3) or
	 * RGB(100, 200, 200, 200). The alpha is skipped when it is 255 (opaque).
	 */
	public static String toString(int packed) {
		int alpha = unsigned(alpha(packed));
		String rgb = unsigned(red(packed)) + ", " + unsigned(green(packed)) + ", " + unsigned(blue(packed));
		if (alpha == 255) return "RGB(" + rgb + ")";
		else return "RGBA(" + rgb + ", " + unsigned(alpha(packed)) + ")";
	}

	/**
	 * Performs a srgb-to-linear conversion on the given srgb value.
	 * <p>
	 * 	This can be useful when you want to use the color of an image file that you have on disk. When you use
	 * 	a color picker in image editing software, you will get the RGBA values of the pixel	<i>after</i> it has been
	 * 	converted to SRGB. When you divide this value by 255f and try to output it from your fragment shader, you will
	 * 	notice that it is probably much brighter than you expected. This problem is caused by the implicit
	 * 	linear-to-srgb conversion when you use an SRGB swapchain image.
	 * </p>
	 * <p>
	 *     You can counteract this problem by using this method to convert the picked value back to linear before
	 *     outputting it in your fragment shader.
	 * </p>
	 */
	public static float srgbToLinear(float srgb) {
		if (srgb <= 0.04f) return srgb / 12.92f;
		else return (float) pow((srgb + 0.055f) / 1.055f, 2.4f);
	}

	/**
	 * This is the inverse of {@link #srgbToLinear(float)}
	 */
	public static float linearToSrgb(float linear) {
		if (linear <= 0.00313f) return 12.92f * linear;
		else return 1.055f * (float) pow(linear, 1f / 2.4f) - 0.055f;
	}

	/**
	 * Applies the srgb-to-linear conversion of {@link #srgbToLinear(float)} to the RGB components of the packed color.
	 * The alpha component is untouched.
	 */
	public static int srgbToLinear(int packedSrgb) {
		return rgba(
				srgbToLinear(normalize(red(packedSrgb))),
				srgbToLinear(normalize(green(packedSrgb))),
				srgbToLinear(normalize(blue(packedSrgb))),
				normalize(alpha(packedSrgb))
		);
	}

	/**
	 * The inverse of {@link #srgbToLinear(int)}
	 */
	public static int linearToSrgb(int packedLinear) {
		return rgba(
				linearToSrgb(normalize(red(packedLinear))),
				linearToSrgb(normalize(green(packedLinear))),
				linearToSrgb(normalize(blue(packedLinear))),
				normalize(alpha(packedLinear))
		);
	}

	/**
	 * Creates a new color with the same red, green, and blue component as {@code color}, but with an alpha of
	 * {@code newAlpha}
	 * @param color The original color
	 * @param newAlpha The new alpha component
	 * @return The new color
	 */
	public static int changeAlpha(int color, byte newAlpha) {
		return rgba(red(color), green(color), blue(color), newAlpha);
	}

	/**
	 * Creates a new color with the same red, green, and blue component as {@code color}, but with an alpha of
	 * {@code newAlpha} (which should be at least 0 and at most 255)
	 * @param color The original color
	 * @param newAlpha The new alpha component
	 * @return The new color
	 */
	public static int changeAlpha(int color, int newAlpha) {
		return changeAlpha(color, (byte) newAlpha);
	}

	/**
	 * Creates a new color with the same red, green, and blue component as {@code color}, but with an alpha of
	 * {@code newAlpha} (which should be at least 0f and at most 1f)
	 * @param color The original color
	 * @param newAlpha The new alpha component
	 * @return The new color
	 */
	public static int changeAlpha(int color, float newAlpha) {
		return changeAlpha(color, denormalize(newAlpha));
	}

	/**
	 * Creates a new color with the same red, green, and blue component as {@code color}, but with an alpha of
	 * {@code factor * alpha(color)}
	 * @param color The original color
	 * @param factor The number with which the alpha component of {@code color} should be multiplied
	 * @return The new color
	 */
	public static int multiplyAlpha(int color, float factor) {
		return changeAlpha(color, factor * normalize(alpha(color)));
	}

	/**
	 * Performs a component-wise addition of the colors {@code a} and {@code b}, and returns the result. If the sum
	 * of any component is larger than 255, it will be clamped to 255.
	 * @param a The 'left' color
	 * @param b The 'right' color
	 * @return The 'sum' of {@code a} and {@code b}
	 */
	public static int addColors(int a, int b) {
		return rgba(
				min(255, unsigned(red(a)) + unsigned(red(b))),
				min(255, unsigned(green(a)) + unsigned(green(b))),
				min(255, unsigned(blue(a)) + unsigned(blue(b))),
				min(255, unsigned(alpha(a)) + unsigned(alpha(b)))
		);
	}

	/**
	 * Performs a component-wise multiplication of the colors {@code a} and {@code b}, and returns the result.
	 * To perform the multiplication, all components (red, green, blue, and alpha) are normalized such that they are at
	 * least 0f and at most 1f.
	 * @param a The 'left' color
	 * @param b The 'right' color
	 * @return The 'product' of {@code a} and {@code b}
	 */
	public static int multiplyColors(int a, int b) {
		return rgba(
				normalize(red(a)) * normalize(red(b)),
				normalize(green(a)) * normalize(green(b)),
				normalize(blue(a)) * normalize(blue(b)),
				normalize(alpha(a)) * normalize(alpha(b))
		);
	}

	/**
	 * Linearly interpolates the colors {@code a} and {@code b}, and returns the result. The result is basically a
	 * component-wise version of {@code (1f - weightB) * a + weightB * b}. Examples:
	 * <ul>
	 * 	   <li>weightB == 0 -> result == a</li>
	 * 	   <li>weightB == 0.2 -> result == 0.8a + 0.2b</li>
	 *     <li>weightB == 1 -> result == b</li>
	 * </ul>
	 * @param a The 'left' color
	 * @param b The 'right' color
	 * @param weightB The weight of the color {@code b}
	 */
	public static int interpolateColors(int a, int b, float weightB) {
		if (weightB <= 0f) return a;
		if (weightB >= 1f) return b;
		return addColors(
				multiplyColors(a, rgba(1f - weightB, 1f - weightB, 1f - weightB, 1f - weightB)),
				multiplyColors(b, rgba(weightB, weightB, weightB, weightB))
		);
	}
}
